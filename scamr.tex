The plant abstraction developed in our earlier
work~\cite{zutshi2014multiple} was shown to be quite powerful in
finding falsifications when only a black box description was
available. The abstraction was built and explored using simulations
and unlike white-box approaches did not exploit the underlying
structure of the system $\scrS$. In this chapter we try to remedy this
by estimating a model of the system and recovering some structure of
the underlying system. Taking such a route can potentially improve the
previously used expensive refinement procedure and also provides us an
alternative perspective on the problem.

\subsection{PWA modeling and Falsification}

The symbolic abstraction of the given system $\scrS$ can be thought of
as a discrete transition system, where each abstract state represents
a location and its relation represents the transition relation. Let
$L: \C \mapsto g(\vx)$ be a map from a cell to its constraint
representation. Then we have, $L(C_i\in\C) \implies \RA{\tau}()$


symbolic maps describing evolution of the system for each cell. This
is akin to computing a piecewise affine, discrete time model of the
system. It also provides us with a way to define relations between two
abstract states. We associate an an affine map $\Map{i}$ with every
abstract state $C_i$, which maps a concrete state in cell $C_i$ to
another concrete state reachable in one time step $\tau$. The time
step parameterized abstract relation $\RA{\tau}$ can be stated in
terms of these maps. Two abstract states are related, if the system
can evolve from one to another in time $\tau$.

$\Map{}$ can be either be soundly approximated using a regression
technique and numerical simulations or can be over-approximated by
symbolic reach set computation tools like flow*~\cite{chen2013flow}.
The resulting abstraction $\hat{\scrS}$ is non-deterministic, and can
be interpreted as a discrete time, piecewise affine model of the
underlying plant. A time bounded reachability question for the system
$\scrS$ can then be encoded as a BMC formula over finite steps and
checked over the abstraction $\hat{\scrS}$ using an SMT solver like
Z3~\cite{DeMoura+Bjorner/08/Z3}. If satisfiable, Z3 returns a path in
the abstraction which is a sequence of abstract states, and indicates
a potential concrete violating trajectory of the given system $\scrS$.
A concretization step is used to discover such a concrete violation.
On the other hand, an unsatisfiable formula indicates the absence of a
counterexample in the abstraction.

We first introduce the template of the piecewise affine model, present
a method to estimate it from a given black box system, and then detail
the resulting abstraction and propose an iterative falsification
methodology.

\paragraph {Assumptions.} We assume that the plant is described as a
black box system equipped with a forward numerical simulation function
$\simulate$.

\section{Answering the Reachability Question}

Approximating a continuous plant $\scrS$ by the abstract transition
system $\hat{\scrS}$ allows us to encode the reachability problem by a
BMC formula. As we kept the map $\Map{}$ affine, we can use
off-the-shelf SMT solvers like Z3~\cite{DeMoura+Bjorner/08/Z3} to
check it. We now formally state the problem.

\paragraph{Problem Statement.} Given a polytope representing unsafe of
states, $X_f: A_f\vx \le \vb_f$, a discrete transition system
$\hat{\scrS}$ defined by $\Map{}$, it's initial set of states (also a
polytope) $X_0: A_0\vx \le \vb_0$, a finite number of steps $N$, does
there exist a trajectory of the system from an initial state $\vx_0
\in X_0$ to an unsafe set such that $\vx_k \in X_f$, where $\vx_k =
\Map{}^k(\vx)$ and $k \le N$.

\subsection{Search for a violation.} Given a BMC formula over affine
arithmetic, an SMT solver either returns a satisfying assignment for
it or finds it unsatisfiable. The former case provide us with an
abstract violation while the latter conveys us the absence of one in
the sound abstraction. To find the corresponding concrete violation if
it exists, a concretization step is used.

\subsection{Concretization} An abstract path can be concretized by
using random simulations. Same as before, we use the initial abstract
state $C_0$ in the returned abstract path and sample it to get
$\scr{N}$ concrete states ($\scr{N}$ is the concretization budget).
The states are then simulated for specified time horizon $T$ using the
given simulation function $\simulate$. If a violation is triggered, we
conclude a successful falsification and stop. If not, we refine the
abstraction.

\subsection{Refinement} A refinement of the abstraction can be carried
out by reducing the error in the relation. The error is captured by
the interval $[\underline{\vb}, \overline{\vb}]$ in the map $\Map{}$.
Multiple strategies can be used to refine the maps, depending upon the
underlying method used to over-approximate the $\Map{}$. One way would
be to reduce the size of the cells by refining the $\epsilon$-tiling.
The interval affine maps thus found using the same method would be
more precise.

\section{Discussion}

There are a few known points which need to be addressed in this
approach. Particularly, an algorithm needs to be designed to explore
the cells and estimate their associated maps. An exhaustive
enumeration is undesirable, and hence there needs to be a mechanism to
prioritize which cells to explore. A potential candidate would be to
use the previously introduced scatter-and simulate algorithm.

Another aspect we need to discuss is the refinement procedure.
Assuming a finer $\epsilon$-tiling has been mentioned, but but perhaps
we can refine each cell individually as per their respective observed
over-approximation. Also, it needs to be investigated if a less
expensive and more flexible state-space decomposition can be used
instead of $\epsilon$-tiling, for \emph{e.g.} simplicial
decomposition.

Finally, if possible, we would like the time step $\tau$ to be dynamic
and dynamics based instead of fixing one for the entire system.


\section{S3CAM + Relation Based Refinement}
In the first approach, we propose to modify the refinement procedure
used by SCAM. Before we proceed, let us briefly recall the general
SCAM algorithm.

\begin{enumerate}
    \item Assume an $\epsilon$-grid.
    \item Scatter and Simulate.\label{s2}
    \item Build a Graph.
    \item Find abstract counterexamples (paths from the initial cell
        to the error cell).
    \item Concretize abstract counterexamples using simulations.
    \item Upon failure, refine by reducing $\epsilon$ and
        repeating from step~\ref{s2}.
\end{enumerate}

SCAM uses the abstract counterexamples to indicate the cells which
need to be refined. These cells are split into their constituent cells
which are then further refined till a concrete counterexample is
found.

The abstraction uses the below two rules to guide the search for
counterexamples.
\begin{itemize}
    \item Reachability.\\
        $\exists \vx_i \in C_i.\; \exists \vx'_i \in C'_i.\;
        \vx_i \areach{} \vx'_i \iff C_i \reach{} C'_i$

    \item Transitivity.\\
        $C_i \reach{} C'_i \wedge C'_i \reach{} C''_i \implies C_i \reach{} C''_i$
\end{itemize}
Given an abstract path $C_i\reach{}C'_i\reach{}C''_i$, the
refinement involves the search for a $\hat{\vx}_i \in C''_i$ and a
$\hat{\vx}''_i \in C_i$, such that $\hat{\vx}_i \areach{} \hat{\vx}$.

\begin{align*}
    \exists \vx_i \in C_i.\; \exists \vx'_i \in C'_i.\; \exists \vx''_i
    \in C'_i.\;  &\vx_i \areach{} \vx'_i \wedge \vx'_i \areach{} \vx''_i\\
    \implies &\exists \hat{\vx}_i \in C_i.\; \exists \hat{\vx}''_i
    \in C''_i.\; \hat{\vx}_i \areach{} \hat{\vx}''_i
\end{align*}
Although the above abstraction indicates the cells which should be
refined, it does not provide a good refinement procedure, and in fact
SCAM uses a brute force technique based on sampling based state search.

Instead, we wamt to find a local model for the evolution of the system
`along the abstract counterexample'. A model which is (a) cheap to
construct, (b) accurate locally, (c) amenable to search for a cocnrete
path. To achieve this we propose modeling of the abstract
counterexample using picewise affine relations. This can be either
done soundly using overapproximate set reachable techniques or by
using statistical regression.

Given an abstract relation $\reach{\tau}\subseteq(\C \times \C)$, we
define an enriched relation $\reach{\Map{}, \tau}$ over the concrete
states of the respective cell. In addition to stating reachability,
$\reach{\Map{}, \tau}$ also provides a local model for computing
concrete pairs of reachable states.

Hence, if $C_i \reach{} C_j$, then we enrich it by computing a
$\Map{i,j}$, such that $\forall \vx_i \in C_i.\; \exists \vx_j \in
C_j.\; \vx_i \areach{} \vx_j \implies \Map{i,j}(\vx_i) \approx \vx_j$.
If we can overapproximate $\Map{i,j}$, then we can bound the error
between $\Map{i,j}(\vx_i)$ and $\vx_j$. Selecting an affine template
has a key benefit; it enables efficient reasoning w.r.t. reachability.
Given a path in the abstraction, we can cast the problem of finding a
path in the enriched abstraction as the feasbility checking problem
for a set of linear inequalities.  A feasible solution to the
resulting linear program predicts a concrete path, the accuracy of
which depends on the local model.

\begin{align}
\min \vx^T \vc\;\; s.t.\\
\bigwedge_{i=0\ldots n} \vx_i \in C_i\\
\bigwedge_{i=0\ldots n} \vx_{i+1} \in A_{i,i+1}\vx_i + \delta
\end{align}

In summary, the new approach is equivalent to first finding the
reachability graph using SCAM, enumerating counterexamples (paths from
the initial cell to the error cell) and then annotating the associated
edges with affine relations. Each counterexample then represents a
linear program, with its feasible region predicting the concrete
counterexample.

If a path is infeasible, we can further analyse the infeasible
constraint set and perhaps comment about it. We can derive
qualitative as well as quantitative information, and use it to either
quantify how 'unreachable' a state is and why is not reachable. We
then discard the path.

%% This is not aaplicable in case  of sound models (either
% statistically sound against the simulations or sound against the
% the given white box model.
% improve our local models (which one and how) - Make sure they are
% overapproximae? and not missing a possible behavior.

%% Salient points: When can the PWA model miss a behavior described by
%% the originial white/black-box model?
%   - when the PWA model is not over aproximate
%   - due to the PWA model capturing behaviors only at discrete times.


Even when a path is feasible, we need to use our previously defined
concretization step to verify if the found initial state leads to an
error state. To recall, this is done by simply using the $\simulate$
function and simulating $k$-times at and around the $e$-neighbourhood
of the feasible region, where $k$ and $e$ define the budget of the
concretization step. If the concretization step fails, we can either
increase the budget or abandon the search, or refine our local models.
How do we refine local models? The error along the enriched path can
be computed. % by linearly transofrming the errors along each
% edge.

% The error at each each $x'$ can be computed. If error ball for the
% $x_f$ is contained entirely inside the unsafe set, then we know that
% we have a violation. If not, then its not clear which model to refine
% and how.
% - Sensitivity of the final path towards the constituent paths.
% - Splitting cells based on regression till the error is contained
% within a given threshold (fixed upfront). The subsequent iterations of
% SCAMR can work towards reducing this error.

% The local models can be refined iteratively by adding the new
% failure witnesses from the concretization step.



% TODO: Problems to be addressed...
% - the discrete system must not jump over an unsafe set.
% - pick a suitable time step $\tau$.
% - use a suitable algorithm (scatter and simulate) to explore the
% implicit abstraction.
% - collect the explored non-terminal cells in a list $CL$.
% - For each cell $C \in CL$, find a linear timed relation
% $\forall x \in C. R_{C}^{\tau}(x,x')$, which describes the
%  given system's reachable state $x'$ at time $t+\tau$ originating from
%  $x \in C$ at time $t$. For \emph{e.g.}, least squares can be used to
%  estimate such a linear map within a given tolerance.
% - The linear timed relations will be of the form $x' = Ax + b + Gu$,
% where $u$ is the input, and $A, b, G$ need to determined.
% - Once linear timed relations are found, we can do either of the
% following:
%     -- encode the cell behaviors as a transition system. Such a system
%     will take the form: $x \in C_i \implies R_{C_i}^{\tau}(x,x')$ A
%     concrete violation of bounded path length can now be searched by
%     encoding the reachability problem as a BMC  query and using an SMT
%     solver.
%     -- using the explored cells, construct a graph with the cells as
%     the nodes and the edges as relations between cells. The edges will
%     be annotated by the discovered linear timed relations. An abstract
%     violation query can now be formulated as a search for a path from
%     the initial cells to the unsafe cells. Such paths can then sent
%     off to an LP solver to find the existence of a concrete violation.

% - Assuming we found a concrete violation in the previous step, we can
% now proceed to concretize the violation for the actual system. If we
% are unable to, we can refine.
%
% - On the other hand, if we could not find any concrete violation in
% the estimated model, we again refine.



%%%%%%%%%%%%%%%%%%%%%%% discard....

% We define an abstraction relation $\RA{\tau}$, parameterized by the
% time step $\tau$ for each abstract state $C \in \scr{C}$, relating the
% concrete state pairs $(x_i,x'_i)$ under the input $u_i \in \Inputs$ as
% $\RA{\tau}(x_i,u_i,x'_i)$. We model this relation by the below map
% $f_C$.
%
% \[RA{\tau}(\vx_i,\vu_i,\vx'_i) \iff
    % \exists \vx_i \in C_i.\; \vx'_i = A\vx + \vb\]
